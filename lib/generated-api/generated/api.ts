/* tslint:disable */
/* eslint-disable */
/**
 * Novel Backend API
 * ## Novel Reading Platform API  Complete REST API for managing novels, chapters, users, and more.  ### Features: - ð Story and Chapter Management - ð JWT Authentication - â­ Favorites and Ratings - ð¬ Comments - ð Reading History - ð¤ AI-powered Recommendations - ð·ï¸ Web Crawling for content  ### Authentication: Most endpoints require JWT authentication. 1. Login via `/api/auth/login` 2. Use the returned `accessToken` in the Authorization header 3. Format: `Bearer {token}` 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@novel-backend.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AuthResponse {
    'accessToken'?: string;
    'refreshToken'?: string;
    'user'?: UserDto;
}
export interface ChapterDto {
    'id'?: number;
    'storyId'?: number;
    'chapterIndex'?: number;
    'title'?: string;
    'rawTitle'?: string;
    'translatedTitle'?: string;
    'rawContent'?: string;
    'crawlStatus'?: string;
    'crawlTime'?: string;
    'translatedContent'?: string;
    'translateStatus'?: string;
    'translateTime'?: string;
    'createdAt'?: string;
}
export interface CommentDto {
    'id'?: number;
    'userId'?: number;
    'userName'?: string;
    'storyId'?: number;
    'content'?: string;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface CrawlJobDto {
    'id'?: number;
    'storyId'?: number;
    'chapterId'?: number;
    'jobType'?: string;
    'status'?: string;
    'attempts'?: number;
    'errorMessage'?: string;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface CrawlNovelRequest {
    'novelUrl': string;
    'startChapter'?: number;
    'endChapter'?: number;
}
export interface CrawlNovelResponse {
    'storyId'?: number;
    'title'?: string;
    'description'?: string;
    'chaptersCrawled'?: number;
    'chaptersSucceeded'?: number;
    'chaptersFailed'?: number;
    'message'?: string;
}
export interface CreateChapterRequest {
    'title'?: string;
    'rawContent'?: string;
    'chapterIndex': number;
}
export interface CreateCommentRequest {
    'storyId': number;
    'content': string;
}
export interface CreateCrawlJobRequest {
    'storyId'?: number;
    'chapterId'?: number;
    'jobType': string;
}
export interface CreateGenreRequest {
    'name': string;
    'description'?: string;
}
export interface CreateRatingRequest {
    'storyId': number;
    'rating': number;
}
export interface CreateRoleRequest {
    'name': string;
    'description'?: string;
}
/**
 * Request to create a new story
 */
export interface CreateStoryRequest {
    /**
     * Story title
     */
    'title': string;
    /**
     * Author name
     */
    'authorName'?: string;
    /**
     * Story description
     */
    'description'?: string;
    /**
     * Cover image URL
     */
    'coverImageUrl'?: string;
    /**
     * Source URL
     */
    'sourceUrl'?: string;
    /**
     * Source site name
     */
    'sourceSite'?: string;
    /**
     * Array of genre IDs to assign to the story
     */
    'genreIds'?: Set<number>;
}
export interface FavoriteDto {
    'id'?: number;
    'userId'?: number;
    'story'?: StoryDto;
    'createdAt'?: string;
}
export interface FavoriteStatusDto {
    'isFavorite'?: boolean;
    'favoriteCount'?: number;
}
export interface GenreDetailDto {
    'id'?: number;
    'name'?: string;
    'description'?: string;
    'storyCount'?: number;
    'createdAt'?: string;
}
/**
 * List of genres associated with this story
 */
export interface GenreDto {
    'id'?: number;
    'name'?: string;
    'description'?: string;
    'createdAt'?: string;
}
export interface LatestChapterDto {
    'id'?: number;
    'storyId'?: number;
    'storyTitle'?: string;
    'storyTranslatedTitle'?: string;
    'chapterIndex'?: number;
    'title'?: string;
    'translatedTitle'?: string;
    'updatedAt'?: string;
}
export interface LatestChapterInfo {
    'id'?: number;
    'chapterIndex'?: number;
    'title'?: string;
    'translatedTitle'?: string;
    'updatedAt'?: string;
}
export interface LoginRequest {
    'email': string;
    'password': string;
}
export interface PageCommentDto {
    'totalPages'?: number;
    'totalElements'?: number;
    'size'?: number;
    'content'?: Array<CommentDto>;
    'number'?: number;
    'numberOfElements'?: number;
    'pageable'?: PageableObject;
    'sort'?: SortObject;
    'first'?: boolean;
    'last'?: boolean;
    'empty'?: boolean;
}
export interface PageFavoriteDto {
    'totalPages'?: number;
    'totalElements'?: number;
    'size'?: number;
    'content'?: Array<FavoriteDto>;
    'number'?: number;
    'numberOfElements'?: number;
    'pageable'?: PageableObject;
    'sort'?: SortObject;
    'first'?: boolean;
    'last'?: boolean;
    'empty'?: boolean;
}
export interface PageRatingDto {
    'totalPages'?: number;
    'totalElements'?: number;
    'size'?: number;
    'content'?: Array<RatingDto>;
    'number'?: number;
    'numberOfElements'?: number;
    'pageable'?: PageableObject;
    'sort'?: SortObject;
    'first'?: boolean;
    'last'?: boolean;
    'empty'?: boolean;
}
export interface PageReadingHistoryDto {
    'totalPages'?: number;
    'totalElements'?: number;
    'size'?: number;
    'content'?: Array<ReadingHistoryDto>;
    'number'?: number;
    'numberOfElements'?: number;
    'pageable'?: PageableObject;
    'sort'?: SortObject;
    'first'?: boolean;
    'last'?: boolean;
    'empty'?: boolean;
}
export interface PageStoryDetailDto {
    'totalPages'?: number;
    'totalElements'?: number;
    'size'?: number;
    'content'?: Array<StoryDetailDto>;
    'number'?: number;
    'numberOfElements'?: number;
    'pageable'?: PageableObject;
    'sort'?: SortObject;
    'first'?: boolean;
    'last'?: boolean;
    'empty'?: boolean;
}
export interface PageStoryDto {
    'totalPages'?: number;
    'totalElements'?: number;
    'size'?: number;
    'content'?: Array<StoryDto>;
    'number'?: number;
    'numberOfElements'?: number;
    'pageable'?: PageableObject;
    'sort'?: SortObject;
    'first'?: boolean;
    'last'?: boolean;
    'empty'?: boolean;
}
export interface PageUserDto {
    'totalPages'?: number;
    'totalElements'?: number;
    'size'?: number;
    'content'?: Array<UserDto>;
    'number'?: number;
    'numberOfElements'?: number;
    'pageable'?: PageableObject;
    'sort'?: SortObject;
    'first'?: boolean;
    'last'?: boolean;
    'empty'?: boolean;
}
export interface Pageable {
    'page'?: number;
    'size'?: number;
    'sort'?: Array<string>;
}
export interface PageableObject {
    'offset'?: number;
    'pageNumber'?: number;
    'pageSize'?: number;
    'sort'?: SortObject;
    'unpaged'?: boolean;
    'paged'?: boolean;
}
export interface RatingDto {
    'id'?: number;
    'userId'?: number;
    'userName'?: string;
    'storyId'?: number;
    'rating'?: number;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface ReadingHistoryDto {
    'id'?: number;
    'userId'?: number;
    'story'?: StoryDto;
    'chapterId'?: number;
    'chapterTitle'?: string;
    'progressPercent'?: number;
    'scrollOffset'?: number;
    'lastReadAt'?: string;
}
export interface RegisterRequest {
    'email': string;
    'password': string;
    'displayName': string;
    'roleName'?: string;
}
export interface RoleDto {
    'id'?: number;
    'name'?: string;
    'description'?: string;
    'createdAt'?: string;
}
export interface SemanticSearchRequest {
    'query'?: string;
    'limit'?: number;
}
export interface SemanticSearchResponse {
    'query'?: string;
    'results'?: Array<StoryDto>;
    'totalResults'?: number;
}
export interface SortObject {
    'empty'?: boolean;
    'unsorted'?: boolean;
    'sorted'?: boolean;
}
export interface StatsSummaryDto {
    'totalStories'?: number;
    'totalGenres'?: number;
    'totalChapters'?: number;
    'totalUsers'?: number;
    'totalViews'?: number;
}
export interface StoryDetailDto {
    'id'?: number;
    'title'?: string;
    'rawTitle'?: string;
    'translatedTitle'?: string;
    'authorName'?: string;
    'rawAuthorName'?: string;
    'translatedAuthorName'?: string;
    'description'?: string;
    'rawDescription'?: string;
    'translatedDescription'?: string;
    'coverImageUrl'?: string;
    'sourceUrl'?: string;
    'sourceSite'?: string;
    'createdAt'?: string;
    'updatedAt'?: string;
    'viewCount'?: number;
    'featured'?: boolean;
    'totalChapters'?: number;
    'averageRating'?: number;
    'totalRatings'?: number;
    'totalComments'?: number;
    'totalFavorites'?: number;
    'genres'?: Array<GenreDto>;
    'latestChapter'?: LatestChapterInfo;
}
/**
 * Story data transfer object
 */
export interface StoryDto {
    /**
     * Story ID
     */
    'id'?: number;
    /**
     * Story title
     */
    'title'?: string;
    /**
     * Raw title (original language)
     */
    'rawTitle'?: string;
    /**
     * Translated title
     */
    'translatedTitle'?: string;
    /**
     * Author name
     */
    'authorName'?: string;
    /**
     * Raw author name (original language)
     */
    'rawAuthorName'?: string;
    /**
     * Translated author name
     */
    'translatedAuthorName'?: string;
    /**
     * Story description
     */
    'description'?: string;
    /**
     * Raw description (original language)
     */
    'rawDescription'?: string;
    /**
     * Translated description
     */
    'translatedDescription'?: string;
    /**
     * Cover image URL
     */
    'coverImageUrl'?: string;
    /**
     * Source URL
     */
    'sourceUrl'?: string;
    /**
     * Source site name
     */
    'sourceSite'?: string;
    /**
     * Creation timestamp
     */
    'createdAt'?: string;
    /**
     * List of genres associated with this story
     */
    'genres'?: Array<GenreDto>;
}
export interface StoryRatingDto {
    'storyId'?: number;
    'averageRating'?: number;
    'totalRatings'?: number;
}
export interface TranslateStoryRequest {
    'storyId'?: number;
    'translateTitle'?: boolean;
    'translateDescription'?: boolean;
}
export interface TranslateStoryResponse {
    'storyId'?: number;
    'originalTitle'?: string;
    'translatedTitle'?: string;
    'originalAuthorName'?: string;
    'translatedAuthorName'?: string;
    'originalDescription'?: string;
    'translatedDescription'?: string;
    'message'?: string;
}
export interface TranslationRequest {
    'text'?: string;
    'sourceLanguage'?: string;
    'targetLanguage'?: string;
}
export interface TranslationResponse {
    'originalText'?: string;
    'translatedText'?: string;
    'sourceLanguage'?: string;
    'targetLanguage'?: string;
}
export interface UpdateChapterRequest {
    'title'?: string;
    'rawContent'?: string;
    'translatedContent'?: string;
    'chapterIndex'?: number;
}
export interface UpdateChapterTranslationRequest {
    'translatedContent'?: string;
}
export interface UpdateCommentRequest {
    'content': string;
}
export interface UpdateGenreRequest {
    'name'?: string;
    'description'?: string;
}
export interface UpdateHistoryRequest {
    'storyId': number;
    'chapterId'?: number;
    'progressPercent'?: number;
    'scrollOffset'?: number;
}
export interface UpdateRatingRequest {
    'rating': number;
}
export interface UpdateRoleRequest {
    'description'?: string;
}
/**
 * Request to update an existing story
 */
export interface UpdateStoryRequest {
    /**
     * Story title
     */
    'title'?: string;
    /**
     * Author name
     */
    'authorName'?: string;
    /**
     * Story description
     */
    'description'?: string;
    /**
     * Cover image URL
     */
    'coverImageUrl'?: string;
    /**
     * Source URL
     */
    'sourceUrl'?: string;
    /**
     * Source site name
     */
    'sourceSite'?: string;
    /**
     * Array of genre IDs to replace all existing genres. Send empty array to remove all genres.
     */
    'genreIds'?: Set<number>;
}
/**
 * Upload response
 */
export interface UploadResponse {
    /**
     * Upload success status
     */
    'success'?: boolean;
    /**
     * Response message
     */
    'message'?: string;
    /**
     * Cloudinary secure URL
     */
    'url'?: string;
    /**
     * Original filename
     */
    'originalFilename'?: string;
}
export interface UserDto {
    'id'?: number;
    'email'?: string;
    'displayName'?: string;
    'createdAt'?: string;
    'active'?: boolean;
    'roles'?: Set<RoleDto>;
}

/**
 * AdminControllerApi - axios parameter creator
 */
export const AdminControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('activateUser', 'userId', userId)
            const localVarPath = `/api/admin/users/{userId}/activate`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {string} roleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRoleToUser: async (userId: number, roleName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('assignRoleToUser', 'userId', userId)
            // verify required parameter 'roleName' is not null or undefined
            assertParamExists('assignRoleToUser', 'roleName', roleName)
            const localVarPath = `/api/admin/users/{userId}/roles/{roleName}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"roleName"}}`, encodeURIComponent(String(roleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateRoleRequest} createRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (createRoleRequest: CreateRoleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRoleRequest' is not null or undefined
            assertParamExists('createRole', 'createRoleRequest', createRoleRequest)
            const localVarPath = `/api/admin/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUser: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deactivateUser', 'userId', userId)
            const localVarPath = `/api/admin/users/{userId}/deactivate`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (roleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('deleteRole', 'roleId', roleId)
            const localVarPath = `/api/admin/roles/{roleId}`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getAllUsers', 'pageable', pageable)
            const localVarPath = `/api/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleById: async (roleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('getRoleById', 'roleId', roleId)
            const localVarPath = `/api/admin/roles/{roleId}`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserById', 'userId', userId)
            const localVarPath = `/api/admin/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/stats/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {string} roleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRoleFromUser: async (userId: number, roleName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeRoleFromUser', 'userId', userId)
            // verify required parameter 'roleName' is not null or undefined
            assertParamExists('removeRoleFromUser', 'roleName', roleName)
            const localVarPath = `/api/admin/users/{userId}/roles/{roleName}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"roleName"}}`, encodeURIComponent(String(roleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} roleId 
         * @param {UpdateRoleRequest} updateRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole: async (roleId: number, updateRoleRequest: UpdateRoleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('updateRole', 'roleId', roleId)
            // verify required parameter 'updateRoleRequest' is not null or undefined
            assertParamExists('updateRole', 'updateRoleRequest', updateRoleRequest)
            const localVarPath = `/api/admin/roles/{roleId}`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminControllerApi - functional programming interface
 */
export const AdminControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateUser(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminControllerApi.activateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} userId 
         * @param {string} roleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignRoleToUser(userId: number, roleName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignRoleToUser(userId, roleName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminControllerApi.assignRoleToUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateRoleRequest} createRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(createRoleRequest: CreateRoleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(createRoleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminControllerApi.createRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateUser(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminControllerApi.deactivateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(roleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminControllerApi.deleteRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRoles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRoles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminControllerApi.getAllRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminControllerApi.getAllUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleById(roleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleById(roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminControllerApi.getRoleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminControllerApi.getUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminControllerApi.getUserStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} userId 
         * @param {string} roleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeRoleFromUser(userId: number, roleName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeRoleFromUser(userId, roleName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminControllerApi.removeRoleFromUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} roleId 
         * @param {UpdateRoleRequest} updateRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRole(roleId: number, updateRoleRequest: UpdateRoleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(roleId, updateRoleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminControllerApi.updateRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminControllerApi - factory interface
 */
export const AdminControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.activateUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {string} roleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRoleToUser(userId: number, roleName: string, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.assignRoleToUser(userId, roleName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateRoleRequest} createRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(createRoleRequest: CreateRoleRequest, options?: RawAxiosRequestConfig): AxiosPromise<RoleDto> {
            return localVarFp.createRole(createRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUser(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.deactivateUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(roleId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRole(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoleDto>> {
            return localVarFp.getAllRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageUserDto> {
            return localVarFp.getAllUsers(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleById(roleId: number, options?: RawAxiosRequestConfig): AxiosPromise<RoleDto> {
            return localVarFp.getRoleById(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.getUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStats(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getUserStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {string} roleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRoleFromUser(userId: number, roleName: string, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.removeRoleFromUser(userId, roleName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} roleId 
         * @param {UpdateRoleRequest} updateRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(roleId: number, updateRoleRequest: UpdateRoleRequest, options?: RawAxiosRequestConfig): AxiosPromise<RoleDto> {
            return localVarFp.updateRole(roleId, updateRoleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminControllerApi - object-oriented interface
 */
export class AdminControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public activateUser(userId: number, options?: RawAxiosRequestConfig) {
        return AdminControllerApiFp(this.configuration).activateUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {string} roleName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public assignRoleToUser(userId: number, roleName: string, options?: RawAxiosRequestConfig) {
        return AdminControllerApiFp(this.configuration).assignRoleToUser(userId, roleName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateRoleRequest} createRoleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRole(createRoleRequest: CreateRoleRequest, options?: RawAxiosRequestConfig) {
        return AdminControllerApiFp(this.configuration).createRole(createRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deactivateUser(userId: number, options?: RawAxiosRequestConfig) {
        return AdminControllerApiFp(this.configuration).deactivateUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRole(roleId: number, options?: RawAxiosRequestConfig) {
        return AdminControllerApiFp(this.configuration).deleteRole(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllRoles(options?: RawAxiosRequestConfig) {
        return AdminControllerApiFp(this.configuration).getAllRoles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllUsers(pageable: Pageable, options?: RawAxiosRequestConfig) {
        return AdminControllerApiFp(this.configuration).getAllUsers(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRoleById(roleId: number, options?: RawAxiosRequestConfig) {
        return AdminControllerApiFp(this.configuration).getRoleById(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserById(userId: number, options?: RawAxiosRequestConfig) {
        return AdminControllerApiFp(this.configuration).getUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserStats(options?: RawAxiosRequestConfig) {
        return AdminControllerApiFp(this.configuration).getUserStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {string} roleName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public removeRoleFromUser(userId: number, roleName: string, options?: RawAxiosRequestConfig) {
        return AdminControllerApiFp(this.configuration).removeRoleFromUser(userId, roleName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} roleId 
     * @param {UpdateRoleRequest} updateRoleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateRole(roleId: number, updateRoleRequest: UpdateRoleRequest, options?: RawAxiosRequestConfig) {
        return AdminControllerApiFp(this.configuration).updateRole(roleId, updateRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AiControllerApi - axios parameter creator
 */
export const AiControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TranslationRequest} translationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoTranslate: async (translationRequest: TranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'translationRequest' is not null or undefined
            assertParamExists('autoTranslate', 'translationRequest', translationRequest)
            const localVarPath = `/api/ai/translate/auto`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(translationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAllEmbeddings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/ai/embeddings/generate-all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateStoryEmbedding: async (storyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('generateStoryEmbedding', 'storyId', storyId)
            const localVarPath = `/api/ai/embeddings/story/{storyId}`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/ai/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshStoryEmbedding: async (storyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('refreshStoryEmbedding', 'storyId', storyId)
            const localVarPath = `/api/ai/embeddings/story/{storyId}/refresh`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SemanticSearchRequest} semanticSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semanticSearch: async (semanticSearchRequest: SemanticSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'semanticSearchRequest' is not null or undefined
            assertParamExists('semanticSearch', 'semanticSearchRequest', semanticSearchRequest)
            const localVarPath = `/api/ai/search/semantic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(semanticSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TranslationRequest} translationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translate: async (translationRequest: TranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'translationRequest' is not null or undefined
            assertParamExists('translate', 'translationRequest', translationRequest)
            const localVarPath = `/api/ai/translate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(translationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AiControllerApi - functional programming interface
 */
export const AiControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AiControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {TranslationRequest} translationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoTranslate(translationRequest: TranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranslationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoTranslate(translationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AiControllerApi.autoTranslate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateAllEmbeddings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateAllEmbeddings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AiControllerApi.generateAllEmbeddings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateStoryEmbedding(storyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateStoryEmbedding(storyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AiControllerApi.generateStoryEmbedding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AiControllerApi.healthCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshStoryEmbedding(storyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshStoryEmbedding(storyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AiControllerApi.refreshStoryEmbedding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SemanticSearchRequest} semanticSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async semanticSearch(semanticSearchRequest: SemanticSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SemanticSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.semanticSearch(semanticSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AiControllerApi.semanticSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TranslationRequest} translationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translate(translationRequest: TranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranslationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translate(translationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AiControllerApi.translate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AiControllerApi - factory interface
 */
export const AiControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AiControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {TranslationRequest} translationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoTranslate(translationRequest: TranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<TranslationResponse> {
            return localVarFp.autoTranslate(translationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAllEmbeddings(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.generateAllEmbeddings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateStoryEmbedding(storyId: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.generateStoryEmbedding(storyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.healthCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshStoryEmbedding(storyId: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.refreshStoryEmbedding(storyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SemanticSearchRequest} semanticSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semanticSearch(semanticSearchRequest: SemanticSearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<SemanticSearchResponse> {
            return localVarFp.semanticSearch(semanticSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TranslationRequest} translationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translate(translationRequest: TranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<TranslationResponse> {
            return localVarFp.translate(translationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AiControllerApi - object-oriented interface
 */
export class AiControllerApi extends BaseAPI {
    /**
     * 
     * @param {TranslationRequest} translationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public autoTranslate(translationRequest: TranslationRequest, options?: RawAxiosRequestConfig) {
        return AiControllerApiFp(this.configuration).autoTranslate(translationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateAllEmbeddings(options?: RawAxiosRequestConfig) {
        return AiControllerApiFp(this.configuration).generateAllEmbeddings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateStoryEmbedding(storyId: number, options?: RawAxiosRequestConfig) {
        return AiControllerApiFp(this.configuration).generateStoryEmbedding(storyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthCheck(options?: RawAxiosRequestConfig) {
        return AiControllerApiFp(this.configuration).healthCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public refreshStoryEmbedding(storyId: number, options?: RawAxiosRequestConfig) {
        return AiControllerApiFp(this.configuration).refreshStoryEmbedding(storyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SemanticSearchRequest} semanticSearchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public semanticSearch(semanticSearchRequest: SemanticSearchRequest, options?: RawAxiosRequestConfig) {
        return AiControllerApiFp(this.configuration).semanticSearch(semanticSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TranslationRequest} translationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public translate(translationRequest: TranslationRequest, options?: RawAxiosRequestConfig) {
        return AiControllerApiFp(this.configuration).translate(translationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthControllerApi - axios parameter creator
 */
export const AuthControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerRequest: RegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            assertParamExists('register', 'registerRequest', registerRequest)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthControllerApi - functional programming interface
 */
export const AuthControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControllerApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControllerApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthControllerApi - factory interface
 */
export const AuthControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.register(registerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthControllerApi - object-oriented interface
 */
export class AuthControllerApi extends BaseAPI {
    /**
     * 
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).register(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChapterControllerApi - axios parameter creator
 */
export const ChapterControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} storyId 
         * @param {CreateChapterRequest} createChapterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChapter: async (storyId: number, createChapterRequest: CreateChapterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('createChapter', 'storyId', storyId)
            // verify required parameter 'createChapterRequest' is not null or undefined
            assertParamExists('createChapter', 'createChapterRequest', createChapterRequest)
            const localVarPath = `/api/stories/{storyId}/chapters`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createChapterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} chapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChapter: async (storyId: number, chapterId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('deleteChapter', 'storyId', storyId)
            // verify required parameter 'chapterId' is not null or undefined
            assertParamExists('deleteChapter', 'chapterId', chapterId)
            const localVarPath = `/api/stories/{storyId}/chapters/{chapterId}`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)))
                .replace(`{${"chapterId"}}`, encodeURIComponent(String(chapterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} chapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChapterById: async (storyId: number, chapterId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('getChapterById', 'storyId', storyId)
            // verify required parameter 'chapterId' is not null or undefined
            assertParamExists('getChapterById', 'chapterId', chapterId)
            const localVarPath = `/api/stories/{storyId}/chapters/{chapterId}`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)))
                .replace(`{${"chapterId"}}`, encodeURIComponent(String(chapterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChaptersByStoryId: async (storyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('getChaptersByStoryId', 'storyId', storyId)
            const localVarPath = `/api/stories/{storyId}/chapters`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryFailedTranslations: async (storyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('retryFailedTranslations', 'storyId', storyId)
            const localVarPath = `/api/stories/{storyId}/chapters/retry-failed-translations`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateAllChapters: async (storyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('translateAllChapters', 'storyId', storyId)
            const localVarPath = `/api/stories/{storyId}/chapters/translate-all`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} chapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateChapter: async (storyId: number, chapterId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('translateChapter', 'storyId', storyId)
            // verify required parameter 'chapterId' is not null or undefined
            assertParamExists('translateChapter', 'chapterId', chapterId)
            const localVarPath = `/api/stories/{storyId}/chapters/{chapterId}/translate`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)))
                .replace(`{${"chapterId"}}`, encodeURIComponent(String(chapterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} chapterId 
         * @param {UpdateChapterRequest} updateChapterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChapter: async (storyId: number, chapterId: number, updateChapterRequest: UpdateChapterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('updateChapter', 'storyId', storyId)
            // verify required parameter 'chapterId' is not null or undefined
            assertParamExists('updateChapter', 'chapterId', chapterId)
            // verify required parameter 'updateChapterRequest' is not null or undefined
            assertParamExists('updateChapter', 'updateChapterRequest', updateChapterRequest)
            const localVarPath = `/api/stories/{storyId}/chapters/{chapterId}`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)))
                .replace(`{${"chapterId"}}`, encodeURIComponent(String(chapterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateChapterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} chapterId 
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCrawlStatus: async (chapterId: number, requestBody: { [key: string]: string; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chapterId' is not null or undefined
            assertParamExists('updateCrawlStatus', 'chapterId', chapterId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateCrawlStatus', 'requestBody', requestBody)
            const localVarPath = `/api/stories/{storyId}/chapters/{chapterId}/crawl-status`
                .replace(`{${"chapterId"}}`, encodeURIComponent(String(chapterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} chapterId 
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRawContent: async (storyId: number, chapterId: number, requestBody: { [key: string]: string; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('updateRawContent', 'storyId', storyId)
            // verify required parameter 'chapterId' is not null or undefined
            assertParamExists('updateRawContent', 'chapterId', chapterId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateRawContent', 'requestBody', requestBody)
            const localVarPath = `/api/stories/{storyId}/chapters/{chapterId}/raw-content`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)))
                .replace(`{${"chapterId"}}`, encodeURIComponent(String(chapterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} chapterId 
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTranslateStatus: async (chapterId: number, requestBody: { [key: string]: string; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chapterId' is not null or undefined
            assertParamExists('updateTranslateStatus', 'chapterId', chapterId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateTranslateStatus', 'requestBody', requestBody)
            const localVarPath = `/api/stories/{storyId}/chapters/{chapterId}/translate-status`
                .replace(`{${"chapterId"}}`, encodeURIComponent(String(chapterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} chapterId 
         * @param {UpdateChapterTranslationRequest} updateChapterTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTranslation: async (storyId: number, chapterId: number, updateChapterTranslationRequest: UpdateChapterTranslationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('updateTranslation', 'storyId', storyId)
            // verify required parameter 'chapterId' is not null or undefined
            assertParamExists('updateTranslation', 'chapterId', chapterId)
            // verify required parameter 'updateChapterTranslationRequest' is not null or undefined
            assertParamExists('updateTranslation', 'updateChapterTranslationRequest', updateChapterTranslationRequest)
            const localVarPath = `/api/stories/{storyId}/chapters/{chapterId}/translation`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)))
                .replace(`{${"chapterId"}}`, encodeURIComponent(String(chapterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateChapterTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChapterControllerApi - functional programming interface
 */
export const ChapterControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChapterControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} storyId 
         * @param {CreateChapterRequest} createChapterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChapter(storyId: number, createChapterRequest: CreateChapterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChapterDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChapter(storyId, createChapterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChapterControllerApi.createChapter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} chapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChapter(storyId: number, chapterId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChapter(storyId, chapterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChapterControllerApi.deleteChapter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} chapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChapterById(storyId: number, chapterId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChapterDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChapterById(storyId, chapterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChapterControllerApi.getChapterById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChaptersByStoryId(storyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChapterDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChaptersByStoryId(storyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChapterControllerApi.getChaptersByStoryId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryFailedTranslations(storyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retryFailedTranslations(storyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChapterControllerApi.retryFailedTranslations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translateAllChapters(storyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translateAllChapters(storyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChapterControllerApi.translateAllChapters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} chapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translateChapter(storyId: number, chapterId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChapterDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translateChapter(storyId, chapterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChapterControllerApi.translateChapter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} chapterId 
         * @param {UpdateChapterRequest} updateChapterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChapter(storyId: number, chapterId: number, updateChapterRequest: UpdateChapterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChapterDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChapter(storyId, chapterId, updateChapterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChapterControllerApi.updateChapter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} chapterId 
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCrawlStatus(chapterId: number, requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCrawlStatus(chapterId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChapterControllerApi.updateCrawlStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} chapterId 
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRawContent(storyId: number, chapterId: number, requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChapterDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRawContent(storyId, chapterId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChapterControllerApi.updateRawContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} chapterId 
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTranslateStatus(chapterId: number, requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTranslateStatus(chapterId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChapterControllerApi.updateTranslateStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} chapterId 
         * @param {UpdateChapterTranslationRequest} updateChapterTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTranslation(storyId: number, chapterId: number, updateChapterTranslationRequest: UpdateChapterTranslationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChapterDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTranslation(storyId, chapterId, updateChapterTranslationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChapterControllerApi.updateTranslation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChapterControllerApi - factory interface
 */
export const ChapterControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChapterControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} storyId 
         * @param {CreateChapterRequest} createChapterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChapter(storyId: number, createChapterRequest: CreateChapterRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChapterDto> {
            return localVarFp.createChapter(storyId, createChapterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} chapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChapter(storyId: number, chapterId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteChapter(storyId, chapterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} chapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChapterById(storyId: number, chapterId: number, options?: RawAxiosRequestConfig): AxiosPromise<ChapterDto> {
            return localVarFp.getChapterById(storyId, chapterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChaptersByStoryId(storyId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ChapterDto>> {
            return localVarFp.getChaptersByStoryId(storyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryFailedTranslations(storyId: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.retryFailedTranslations(storyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateAllChapters(storyId: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.translateAllChapters(storyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} chapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateChapter(storyId: number, chapterId: number, options?: RawAxiosRequestConfig): AxiosPromise<ChapterDto> {
            return localVarFp.translateChapter(storyId, chapterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} chapterId 
         * @param {UpdateChapterRequest} updateChapterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChapter(storyId: number, chapterId: number, updateChapterRequest: UpdateChapterRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChapterDto> {
            return localVarFp.updateChapter(storyId, chapterId, updateChapterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} chapterId 
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCrawlStatus(chapterId: number, requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateCrawlStatus(chapterId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} chapterId 
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRawContent(storyId: number, chapterId: number, requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig): AxiosPromise<ChapterDto> {
            return localVarFp.updateRawContent(storyId, chapterId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} chapterId 
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTranslateStatus(chapterId: number, requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateTranslateStatus(chapterId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} chapterId 
         * @param {UpdateChapterTranslationRequest} updateChapterTranslationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTranslation(storyId: number, chapterId: number, updateChapterTranslationRequest: UpdateChapterTranslationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChapterDto> {
            return localVarFp.updateTranslation(storyId, chapterId, updateChapterTranslationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChapterControllerApi - object-oriented interface
 */
export class ChapterControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} storyId 
     * @param {CreateChapterRequest} createChapterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createChapter(storyId: number, createChapterRequest: CreateChapterRequest, options?: RawAxiosRequestConfig) {
        return ChapterControllerApiFp(this.configuration).createChapter(storyId, createChapterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {number} chapterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteChapter(storyId: number, chapterId: number, options?: RawAxiosRequestConfig) {
        return ChapterControllerApiFp(this.configuration).deleteChapter(storyId, chapterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {number} chapterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getChapterById(storyId: number, chapterId: number, options?: RawAxiosRequestConfig) {
        return ChapterControllerApiFp(this.configuration).getChapterById(storyId, chapterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getChaptersByStoryId(storyId: number, options?: RawAxiosRequestConfig) {
        return ChapterControllerApiFp(this.configuration).getChaptersByStoryId(storyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retryFailedTranslations(storyId: number, options?: RawAxiosRequestConfig) {
        return ChapterControllerApiFp(this.configuration).retryFailedTranslations(storyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public translateAllChapters(storyId: number, options?: RawAxiosRequestConfig) {
        return ChapterControllerApiFp(this.configuration).translateAllChapters(storyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {number} chapterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public translateChapter(storyId: number, chapterId: number, options?: RawAxiosRequestConfig) {
        return ChapterControllerApiFp(this.configuration).translateChapter(storyId, chapterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {number} chapterId 
     * @param {UpdateChapterRequest} updateChapterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateChapter(storyId: number, chapterId: number, updateChapterRequest: UpdateChapterRequest, options?: RawAxiosRequestConfig) {
        return ChapterControllerApiFp(this.configuration).updateChapter(storyId, chapterId, updateChapterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} chapterId 
     * @param {{ [key: string]: string; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateCrawlStatus(chapterId: number, requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig) {
        return ChapterControllerApiFp(this.configuration).updateCrawlStatus(chapterId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {number} chapterId 
     * @param {{ [key: string]: string; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateRawContent(storyId: number, chapterId: number, requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig) {
        return ChapterControllerApiFp(this.configuration).updateRawContent(storyId, chapterId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} chapterId 
     * @param {{ [key: string]: string; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateTranslateStatus(chapterId: number, requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig) {
        return ChapterControllerApiFp(this.configuration).updateTranslateStatus(chapterId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {number} chapterId 
     * @param {UpdateChapterTranslationRequest} updateChapterTranslationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateTranslation(storyId: number, chapterId: number, updateChapterTranslationRequest: UpdateChapterTranslationRequest, options?: RawAxiosRequestConfig) {
        return ChapterControllerApiFp(this.configuration).updateTranslation(storyId, chapterId, updateChapterTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CloudinaryApi - axios parameter creator
 */
export const CloudinaryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload an image to Cloudinary with automatic WebP conversion and optimization. Images are stored in the \'novel_covers\' folder. Requires ADMIN or MODERATOR role.
         * @summary Upload novel cover image
         * @param {File} file Image file to upload (JPG, PNG, GIF, WebP supported)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadImage: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadImage', 'file', file)
            const localVarPath = `/api/cloudinary/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudinaryApi - functional programming interface
 */
export const CloudinaryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudinaryApiAxiosParamCreator(configuration)
    return {
        /**
         * Upload an image to Cloudinary with automatic WebP conversion and optimization. Images are stored in the \'novel_covers\' folder. Requires ADMIN or MODERATOR role.
         * @summary Upload novel cover image
         * @param {File} file Image file to upload (JPG, PNG, GIF, WebP supported)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadImage(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadImage(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudinaryApi.uploadImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CloudinaryApi - factory interface
 */
export const CloudinaryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudinaryApiFp(configuration)
    return {
        /**
         * Upload an image to Cloudinary with automatic WebP conversion and optimization. Images are stored in the \'novel_covers\' folder. Requires ADMIN or MODERATOR role.
         * @summary Upload novel cover image
         * @param {File} file Image file to upload (JPG, PNG, GIF, WebP supported)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadImage(file: File, options?: RawAxiosRequestConfig): AxiosPromise<UploadResponse> {
            return localVarFp.uploadImage(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudinaryApi - object-oriented interface
 */
export class CloudinaryApi extends BaseAPI {
    /**
     * Upload an image to Cloudinary with automatic WebP conversion and optimization. Images are stored in the \'novel_covers\' folder. Requires ADMIN or MODERATOR role.
     * @summary Upload novel cover image
     * @param {File} file Image file to upload (JPG, PNG, GIF, WebP supported)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadImage(file: File, options?: RawAxiosRequestConfig) {
        return CloudinaryApiFp(this.configuration).uploadImage(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CommentControllerApi - axios parameter creator
 */
export const CommentControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCommentRequest} createCommentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment: async (createCommentRequest: CreateCommentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCommentRequest' is not null or undefined
            assertParamExists('createComment', 'createCommentRequest', createCommentRequest)
            const localVarPath = `/api/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCommentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment: async (commentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('deleteComment', 'commentId', commentId)
            const localVarPath = `/api/comments/{commentId}`
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentById: async (commentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('getCommentById', 'commentId', commentId)
            const localVarPath = `/api/comments/{commentId}`
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentCountByStory: async (storyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('getCommentCountByStory', 'storyId', storyId)
            const localVarPath = `/api/comments/story/{storyId}/count`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentsByStory: async (storyId: number, pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('getCommentsByStory', 'storyId', storyId)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getCommentsByStory', 'pageable', pageable)
            const localVarPath = `/api/comments/story/{storyId}`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyComments: async (pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getMyComments', 'pageable', pageable)
            const localVarPath = `/api/comments/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} commentId 
         * @param {UpdateCommentRequest} updateCommentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateComment: async (commentId: number, updateCommentRequest: UpdateCommentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('updateComment', 'commentId', commentId)
            // verify required parameter 'updateCommentRequest' is not null or undefined
            assertParamExists('updateComment', 'updateCommentRequest', updateCommentRequest)
            const localVarPath = `/api/comments/{commentId}`
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCommentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentControllerApi - functional programming interface
 */
export const CommentControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommentControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateCommentRequest} createCommentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createComment(createCommentRequest: CreateCommentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createComment(createCommentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentControllerApi.createComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteComment(commentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteComment(commentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentControllerApi.deleteComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommentById(commentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommentById(commentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentControllerApi.getCommentById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommentCountByStory(storyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommentCountByStory(storyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentControllerApi.getCommentCountByStory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommentsByStory(storyId: number, pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageCommentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommentsByStory(storyId, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentControllerApi.getCommentsByStory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyComments(pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageCommentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyComments(pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentControllerApi.getMyComments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} commentId 
         * @param {UpdateCommentRequest} updateCommentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateComment(commentId: number, updateCommentRequest: UpdateCommentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateComment(commentId, updateCommentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentControllerApi.updateComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommentControllerApi - factory interface
 */
export const CommentControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommentControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateCommentRequest} createCommentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment(createCommentRequest: CreateCommentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommentDto> {
            return localVarFp.createComment(createCommentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(commentId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteComment(commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentById(commentId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommentDto> {
            return localVarFp.getCommentById(commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentCountByStory(storyId: number, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getCommentCountByStory(storyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentsByStory(storyId: number, pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageCommentDto> {
            return localVarFp.getCommentsByStory(storyId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyComments(pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageCommentDto> {
            return localVarFp.getMyComments(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} commentId 
         * @param {UpdateCommentRequest} updateCommentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateComment(commentId: number, updateCommentRequest: UpdateCommentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommentDto> {
            return localVarFp.updateComment(commentId, updateCommentRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommentControllerApi - object-oriented interface
 */
export class CommentControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateCommentRequest} createCommentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createComment(createCommentRequest: CreateCommentRequest, options?: RawAxiosRequestConfig) {
        return CommentControllerApiFp(this.configuration).createComment(createCommentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteComment(commentId: number, options?: RawAxiosRequestConfig) {
        return CommentControllerApiFp(this.configuration).deleteComment(commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCommentById(commentId: number, options?: RawAxiosRequestConfig) {
        return CommentControllerApiFp(this.configuration).getCommentById(commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCommentCountByStory(storyId: number, options?: RawAxiosRequestConfig) {
        return CommentControllerApiFp(this.configuration).getCommentCountByStory(storyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCommentsByStory(storyId: number, pageable: Pageable, options?: RawAxiosRequestConfig) {
        return CommentControllerApiFp(this.configuration).getCommentsByStory(storyId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMyComments(pageable: Pageable, options?: RawAxiosRequestConfig) {
        return CommentControllerApiFp(this.configuration).getMyComments(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} commentId 
     * @param {UpdateCommentRequest} updateCommentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateComment(commentId: number, updateCommentRequest: UpdateCommentRequest, options?: RawAxiosRequestConfig) {
        return CommentControllerApiFp(this.configuration).updateComment(commentId, updateCommentRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CrawlControllerApi - axios parameter creator
 */
export const CrawlControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CrawlNovelRequest} crawlNovelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlSyosetuNovel: async (crawlNovelRequest: CrawlNovelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'crawlNovelRequest' is not null or undefined
            assertParamExists('crawlSyosetuNovel', 'crawlNovelRequest', crawlNovelRequest)
            const localVarPath = `/api/crawl/syosetu`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(crawlNovelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/crawl/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CrawlControllerApi - functional programming interface
 */
export const CrawlControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CrawlControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CrawlNovelRequest} crawlNovelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crawlSyosetuNovel(crawlNovelRequest: CrawlNovelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrawlNovelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crawlSyosetuNovel(crawlNovelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlControllerApi.crawlSyosetuNovel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async health1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.health1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlControllerApi.health1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CrawlControllerApi - factory interface
 */
export const CrawlControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CrawlControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CrawlNovelRequest} crawlNovelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlSyosetuNovel(crawlNovelRequest: CrawlNovelRequest, options?: RawAxiosRequestConfig): AxiosPromise<CrawlNovelResponse> {
            return localVarFp.crawlSyosetuNovel(crawlNovelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health1(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.health1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CrawlControllerApi - object-oriented interface
 */
export class CrawlControllerApi extends BaseAPI {
    /**
     * 
     * @param {CrawlNovelRequest} crawlNovelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public crawlSyosetuNovel(crawlNovelRequest: CrawlNovelRequest, options?: RawAxiosRequestConfig) {
        return CrawlControllerApiFp(this.configuration).crawlSyosetuNovel(crawlNovelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public health1(options?: RawAxiosRequestConfig) {
        return CrawlControllerApiFp(this.configuration).health1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CrawlJobControllerApi - axios parameter creator
 */
export const CrawlJobControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCrawlJobRequest} createCrawlJobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob: async (createCrawlJobRequest: CreateCrawlJobRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCrawlJobRequest' is not null or undefined
            assertParamExists('createJob', 'createCrawlJobRequest', createCrawlJobRequest)
            const localVarPath = `/api/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCrawlJobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteJob', 'id', id)
            const localVarPath = `/api/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllJobs: async (status?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getJobById', 'id', id)
            const localVarPath = `/api/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} chapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsByChapter: async (chapterId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chapterId' is not null or undefined
            assertParamExists('getJobsByChapter', 'chapterId', chapterId)
            const localVarPath = `/api/jobs/by-chapter/{chapterId}`
                .replace(`{${"chapterId"}}`, encodeURIComponent(String(chapterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {string} [jobType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsByStory: async (storyId: number, jobType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('getJobsByStory', 'storyId', storyId)
            const localVarPath = `/api/jobs/by-story/{storyId}`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (jobType !== undefined) {
                localVarQueryParameter['jobType'] = jobType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobStatus: async (id: number, requestBody: { [key: string]: string; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateJobStatus', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateJobStatus', 'requestBody', requestBody)
            const localVarPath = `/api/jobs/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CrawlJobControllerApi - functional programming interface
 */
export const CrawlJobControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CrawlJobControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateCrawlJobRequest} createCrawlJobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJob(createCrawlJobRequest: CreateCrawlJobRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrawlJobDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJob(createCrawlJobRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlJobControllerApi.createJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJob(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJob(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlJobControllerApi.deleteJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllJobs(status?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CrawlJobDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllJobs(status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlJobControllerApi.getAllJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrawlJobDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlJobControllerApi.getJobById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} chapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobsByChapter(chapterId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CrawlJobDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobsByChapter(chapterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlJobControllerApi.getJobsByChapter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {string} [jobType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobsByStory(storyId: number, jobType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CrawlJobDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobsByStory(storyId, jobType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlJobControllerApi.getJobsByStory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateJobStatus(id: number, requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrawlJobDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateJobStatus(id, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrawlJobControllerApi.updateJobStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CrawlJobControllerApi - factory interface
 */
export const CrawlJobControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CrawlJobControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateCrawlJobRequest} createCrawlJobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob(createCrawlJobRequest: CreateCrawlJobRequest, options?: RawAxiosRequestConfig): AxiosPromise<CrawlJobDto> {
            return localVarFp.createJob(createCrawlJobRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteJob(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllJobs(status?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CrawlJobDto>> {
            return localVarFp.getAllJobs(status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<CrawlJobDto> {
            return localVarFp.getJobById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} chapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsByChapter(chapterId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<CrawlJobDto>> {
            return localVarFp.getJobsByChapter(chapterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {string} [jobType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsByStory(storyId: number, jobType?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CrawlJobDto>> {
            return localVarFp.getJobsByStory(storyId, jobType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobStatus(id: number, requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig): AxiosPromise<CrawlJobDto> {
            return localVarFp.updateJobStatus(id, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CrawlJobControllerApi - object-oriented interface
 */
export class CrawlJobControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateCrawlJobRequest} createCrawlJobRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createJob(createCrawlJobRequest: CreateCrawlJobRequest, options?: RawAxiosRequestConfig) {
        return CrawlJobControllerApiFp(this.configuration).createJob(createCrawlJobRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteJob(id: number, options?: RawAxiosRequestConfig) {
        return CrawlJobControllerApiFp(this.configuration).deleteJob(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllJobs(status?: string, options?: RawAxiosRequestConfig) {
        return CrawlJobControllerApiFp(this.configuration).getAllJobs(status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getJobById(id: number, options?: RawAxiosRequestConfig) {
        return CrawlJobControllerApiFp(this.configuration).getJobById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} chapterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getJobsByChapter(chapterId: number, options?: RawAxiosRequestConfig) {
        return CrawlJobControllerApiFp(this.configuration).getJobsByChapter(chapterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {string} [jobType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getJobsByStory(storyId: number, jobType?: string, options?: RawAxiosRequestConfig) {
        return CrawlJobControllerApiFp(this.configuration).getJobsByStory(storyId, jobType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {{ [key: string]: string; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateJobStatus(id: number, requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig) {
        return CrawlJobControllerApiFp(this.configuration).updateJobStatus(id, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExportApi - axios parameter creator
 */
export const ExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate and download an EPUB file for a story. Optionally specify chapter range.
         * @summary Export story to EPUB format
         * @param {number} storyId Story ID
         * @param {number} [start] Start chapter index (optional, inclusive)
         * @param {number} [end] End chapter index (optional, inclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportToEpub: async (storyId: number, start?: number, end?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('exportToEpub', 'storyId', storyId)
            const localVarPath = `/api/export/{storyId}/epub`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportApi - functional programming interface
 */
export const ExportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExportApiAxiosParamCreator(configuration)
    return {
        /**
         * Generate and download an EPUB file for a story. Optionally specify chapter range.
         * @summary Export story to EPUB format
         * @param {number} storyId Story ID
         * @param {number} [start] Start chapter index (optional, inclusive)
         * @param {number} [end] End chapter index (optional, inclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportToEpub(storyId: number, start?: number, end?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportToEpub(storyId, start, end, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExportApi.exportToEpub']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExportApi - factory interface
 */
export const ExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExportApiFp(configuration)
    return {
        /**
         * Generate and download an EPUB file for a story. Optionally specify chapter range.
         * @summary Export story to EPUB format
         * @param {number} storyId Story ID
         * @param {number} [start] Start chapter index (optional, inclusive)
         * @param {number} [end] End chapter index (optional, inclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportToEpub(storyId: number, start?: number, end?: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.exportToEpub(storyId, start, end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExportApi - object-oriented interface
 */
export class ExportApi extends BaseAPI {
    /**
     * Generate and download an EPUB file for a story. Optionally specify chapter range.
     * @summary Export story to EPUB format
     * @param {number} storyId Story ID
     * @param {number} [start] Start chapter index (optional, inclusive)
     * @param {number} [end] End chapter index (optional, inclusive)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public exportToEpub(storyId: number, start?: number, end?: number, options?: RawAxiosRequestConfig) {
        return ExportApiFp(this.configuration).exportToEpub(storyId, start, end, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FavoriteControllerApi - axios parameter creator
 */
export const FavoriteControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToFavorites: async (storyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('addToFavorites', 'storyId', storyId)
            const localVarPath = `/api/favorites/{storyId}`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkFavoriteStatus: async (storyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('checkFavoriteStatus', 'storyId', storyId)
            const localVarPath = `/api/favorites/check/{storyId}`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoriteCount: async (storyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('getFavoriteCount', 'storyId', storyId)
            const localVarPath = `/api/favorites/count/{storyId}`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFavorites: async (pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getUserFavorites', 'pageable', pageable)
            const localVarPath = `/api/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromFavorites: async (storyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('removeFromFavorites', 'storyId', storyId)
            const localVarPath = `/api/favorites/{storyId}`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FavoriteControllerApi - functional programming interface
 */
export const FavoriteControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FavoriteControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addToFavorites(storyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FavoriteDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addToFavorites(storyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FavoriteControllerApi.addToFavorites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkFavoriteStatus(storyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FavoriteStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkFavoriteStatus(storyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FavoriteControllerApi.checkFavoriteStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFavoriteCount(storyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFavoriteCount(storyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FavoriteControllerApi.getFavoriteCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFavorites(pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageFavoriteDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFavorites(pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FavoriteControllerApi.getUserFavorites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFromFavorites(storyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeFromFavorites(storyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FavoriteControllerApi.removeFromFavorites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FavoriteControllerApi - factory interface
 */
export const FavoriteControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FavoriteControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToFavorites(storyId: number, options?: RawAxiosRequestConfig): AxiosPromise<FavoriteDto> {
            return localVarFp.addToFavorites(storyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkFavoriteStatus(storyId: number, options?: RawAxiosRequestConfig): AxiosPromise<FavoriteStatusDto> {
            return localVarFp.checkFavoriteStatus(storyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoriteCount(storyId: number, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getFavoriteCount(storyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFavorites(pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageFavoriteDto> {
            return localVarFp.getUserFavorites(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromFavorites(storyId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeFromFavorites(storyId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FavoriteControllerApi - object-oriented interface
 */
export class FavoriteControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} storyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addToFavorites(storyId: number, options?: RawAxiosRequestConfig) {
        return FavoriteControllerApiFp(this.configuration).addToFavorites(storyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public checkFavoriteStatus(storyId: number, options?: RawAxiosRequestConfig) {
        return FavoriteControllerApiFp(this.configuration).checkFavoriteStatus(storyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFavoriteCount(storyId: number, options?: RawAxiosRequestConfig) {
        return FavoriteControllerApiFp(this.configuration).getFavoriteCount(storyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserFavorites(pageable: Pageable, options?: RawAxiosRequestConfig) {
        return FavoriteControllerApiFp(this.configuration).getUserFavorites(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public removeFromFavorites(storyId: number, options?: RawAxiosRequestConfig) {
        return FavoriteControllerApiFp(this.configuration).removeFromFavorites(storyId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GenreControllerApi - axios parameter creator
 */
export const GenreControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateGenreRequest} createGenreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGenre: async (createGenreRequest: CreateGenreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGenreRequest' is not null or undefined
            assertParamExists('createGenre', 'createGenreRequest', createGenreRequest)
            const localVarPath = `/api/genres`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGenreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGenre: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGenre', 'id', id)
            const localVarPath = `/api/genres/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGenres: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/genres`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGenresWithCounts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/genres/with-counts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenreById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGenreById', 'id', id)
            const localVarPath = `/api/genres/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenreByName: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getGenreByName', 'name', name)
            const localVarPath = `/api/genres/name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateGenreRequest} updateGenreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGenre: async (id: number, updateGenreRequest: UpdateGenreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGenre', 'id', id)
            // verify required parameter 'updateGenreRequest' is not null or undefined
            assertParamExists('updateGenre', 'updateGenreRequest', updateGenreRequest)
            const localVarPath = `/api/genres/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGenreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GenreControllerApi - functional programming interface
 */
export const GenreControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GenreControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateGenreRequest} createGenreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGenre(createGenreRequest: CreateGenreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenreDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGenre(createGenreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenreControllerApi.createGenre']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGenre(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGenre(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenreControllerApi.deleteGenre']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllGenres(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GenreDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllGenres(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenreControllerApi.getAllGenres']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllGenresWithCounts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GenreDetailDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllGenresWithCounts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenreControllerApi.getAllGenresWithCounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenreById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenreDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGenreById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenreControllerApi.getGenreById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenreByName(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenreDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGenreByName(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenreControllerApi.getGenreByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateGenreRequest} updateGenreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGenre(id: number, updateGenreRequest: UpdateGenreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenreDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGenre(id, updateGenreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenreControllerApi.updateGenre']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GenreControllerApi - factory interface
 */
export const GenreControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GenreControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateGenreRequest} createGenreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGenre(createGenreRequest: CreateGenreRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenreDto> {
            return localVarFp.createGenre(createGenreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGenre(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGenre(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGenres(options?: RawAxiosRequestConfig): AxiosPromise<Array<GenreDto>> {
            return localVarFp.getAllGenres(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGenresWithCounts(options?: RawAxiosRequestConfig): AxiosPromise<Array<GenreDetailDto>> {
            return localVarFp.getAllGenresWithCounts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenreById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<GenreDto> {
            return localVarFp.getGenreById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenreByName(name: string, options?: RawAxiosRequestConfig): AxiosPromise<GenreDto> {
            return localVarFp.getGenreByName(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateGenreRequest} updateGenreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGenre(id: number, updateGenreRequest: UpdateGenreRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenreDto> {
            return localVarFp.updateGenre(id, updateGenreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GenreControllerApi - object-oriented interface
 */
export class GenreControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateGenreRequest} createGenreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createGenre(createGenreRequest: CreateGenreRequest, options?: RawAxiosRequestConfig) {
        return GenreControllerApiFp(this.configuration).createGenre(createGenreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteGenre(id: number, options?: RawAxiosRequestConfig) {
        return GenreControllerApiFp(this.configuration).deleteGenre(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllGenres(options?: RawAxiosRequestConfig) {
        return GenreControllerApiFp(this.configuration).getAllGenres(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllGenresWithCounts(options?: RawAxiosRequestConfig) {
        return GenreControllerApiFp(this.configuration).getAllGenresWithCounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGenreById(id: number, options?: RawAxiosRequestConfig) {
        return GenreControllerApiFp(this.configuration).getGenreById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGenreByName(name: string, options?: RawAxiosRequestConfig) {
        return GenreControllerApiFp(this.configuration).getGenreByName(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateGenreRequest} updateGenreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateGenre(id: number, updateGenreRequest: UpdateGenreRequest, options?: RawAxiosRequestConfig) {
        return GenreControllerApiFp(this.configuration).updateGenre(id, updateGenreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthControllerApi - axios parameter creator
 */
export const HealthControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthControllerApi - functional programming interface
 */
export const HealthControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async health(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.health(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthControllerApi.health']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthControllerApi - factory interface
 */
export const HealthControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.health(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthControllerApi - object-oriented interface
 */
export class HealthControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public health(options?: RawAxiosRequestConfig) {
        return HealthControllerApiFp(this.configuration).health(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LatestChaptersControllerApi - axios parameter creator
 */
export const LatestChaptersControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestChapters: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/chapters/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LatestChaptersControllerApi - functional programming interface
 */
export const LatestChaptersControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LatestChaptersControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestChapters(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LatestChapterDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestChapters(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LatestChaptersControllerApi.getLatestChapters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LatestChaptersControllerApi - factory interface
 */
export const LatestChaptersControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LatestChaptersControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestChapters(limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<LatestChapterDto>> {
            return localVarFp.getLatestChapters(limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LatestChaptersControllerApi - object-oriented interface
 */
export class LatestChaptersControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLatestChapters(limit?: number, options?: RawAxiosRequestConfig) {
        return LatestChaptersControllerApiFp(this.configuration).getLatestChapters(limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RatingControllerApi - axios parameter creator
 */
export const RatingControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateRatingRequest} createRatingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateRating: async (createRatingRequest: CreateRatingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRatingRequest' is not null or undefined
            assertParamExists('createOrUpdateRating', 'createRatingRequest', createRatingRequest)
            const localVarPath = `/api/ratings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRatingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} ratingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRating: async (ratingId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ratingId' is not null or undefined
            assertParamExists('deleteRating', 'ratingId', ratingId)
            const localVarPath = `/api/ratings/{ratingId}`
                .replace(`{${"ratingId"}}`, encodeURIComponent(String(ratingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyRatingForStory: async (storyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('getMyRatingForStory', 'storyId', storyId)
            const localVarPath = `/api/ratings/story/{storyId}/me`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyRatings: async (pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getMyRatings', 'pageable', pageable)
            const localVarPath = `/api/ratings/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingsByStory: async (storyId: number, pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('getRatingsByStory', 'storyId', storyId)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getRatingsByStory', 'pageable', pageable)
            const localVarPath = `/api/ratings/story/{storyId}`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryRating: async (storyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('getStoryRating', 'storyId', storyId)
            const localVarPath = `/api/ratings/story/{storyId}/average`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} ratingId 
         * @param {UpdateRatingRequest} updateRatingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRating: async (ratingId: number, updateRatingRequest: UpdateRatingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ratingId' is not null or undefined
            assertParamExists('updateRating', 'ratingId', ratingId)
            // verify required parameter 'updateRatingRequest' is not null or undefined
            assertParamExists('updateRating', 'updateRatingRequest', updateRatingRequest)
            const localVarPath = `/api/ratings/{ratingId}`
                .replace(`{${"ratingId"}}`, encodeURIComponent(String(ratingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRatingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RatingControllerApi - functional programming interface
 */
export const RatingControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RatingControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateRatingRequest} createRatingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateRating(createRatingRequest: CreateRatingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RatingDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateRating(createRatingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RatingControllerApi.createOrUpdateRating']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} ratingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRating(ratingId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRating(ratingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RatingControllerApi.deleteRating']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyRatingForStory(storyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RatingDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyRatingForStory(storyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RatingControllerApi.getMyRatingForStory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyRatings(pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageRatingDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyRatings(pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RatingControllerApi.getMyRatings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRatingsByStory(storyId: number, pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageRatingDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRatingsByStory(storyId, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RatingControllerApi.getRatingsByStory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStoryRating(storyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoryRatingDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStoryRating(storyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RatingControllerApi.getStoryRating']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} ratingId 
         * @param {UpdateRatingRequest} updateRatingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRating(ratingId: number, updateRatingRequest: UpdateRatingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RatingDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRating(ratingId, updateRatingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RatingControllerApi.updateRating']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RatingControllerApi - factory interface
 */
export const RatingControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RatingControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateRatingRequest} createRatingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateRating(createRatingRequest: CreateRatingRequest, options?: RawAxiosRequestConfig): AxiosPromise<RatingDto> {
            return localVarFp.createOrUpdateRating(createRatingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} ratingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRating(ratingId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRating(ratingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyRatingForStory(storyId: number, options?: RawAxiosRequestConfig): AxiosPromise<RatingDto> {
            return localVarFp.getMyRatingForStory(storyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyRatings(pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageRatingDto> {
            return localVarFp.getMyRatings(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingsByStory(storyId: number, pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageRatingDto> {
            return localVarFp.getRatingsByStory(storyId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryRating(storyId: number, options?: RawAxiosRequestConfig): AxiosPromise<StoryRatingDto> {
            return localVarFp.getStoryRating(storyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} ratingId 
         * @param {UpdateRatingRequest} updateRatingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRating(ratingId: number, updateRatingRequest: UpdateRatingRequest, options?: RawAxiosRequestConfig): AxiosPromise<RatingDto> {
            return localVarFp.updateRating(ratingId, updateRatingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RatingControllerApi - object-oriented interface
 */
export class RatingControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateRatingRequest} createRatingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createOrUpdateRating(createRatingRequest: CreateRatingRequest, options?: RawAxiosRequestConfig) {
        return RatingControllerApiFp(this.configuration).createOrUpdateRating(createRatingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} ratingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRating(ratingId: number, options?: RawAxiosRequestConfig) {
        return RatingControllerApiFp(this.configuration).deleteRating(ratingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMyRatingForStory(storyId: number, options?: RawAxiosRequestConfig) {
        return RatingControllerApiFp(this.configuration).getMyRatingForStory(storyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMyRatings(pageable: Pageable, options?: RawAxiosRequestConfig) {
        return RatingControllerApiFp(this.configuration).getMyRatings(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRatingsByStory(storyId: number, pageable: Pageable, options?: RawAxiosRequestConfig) {
        return RatingControllerApiFp(this.configuration).getRatingsByStory(storyId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStoryRating(storyId: number, options?: RawAxiosRequestConfig) {
        return RatingControllerApiFp(this.configuration).getStoryRating(storyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} ratingId 
     * @param {UpdateRatingRequest} updateRatingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateRating(ratingId: number, updateRatingRequest: UpdateRatingRequest, options?: RawAxiosRequestConfig) {
        return RatingControllerApiFp(this.configuration).updateRating(ratingId, updateRatingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReadingHistoryControllerApi - axios parameter creator
 */
export const ReadingHistoryControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReadingHistory: async (pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getReadingHistory', 'pageable', pageable)
            const localVarPath = `/api/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateHistoryRequest} updateHistoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReadingProgress: async (updateHistoryRequest: UpdateHistoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateHistoryRequest' is not null or undefined
            assertParamExists('updateReadingProgress', 'updateHistoryRequest', updateHistoryRequest)
            const localVarPath = `/api/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateHistoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReadingHistoryControllerApi - functional programming interface
 */
export const ReadingHistoryControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReadingHistoryControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReadingHistory(pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageReadingHistoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReadingHistory(pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReadingHistoryControllerApi.getReadingHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateHistoryRequest} updateHistoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReadingProgress(updateHistoryRequest: UpdateHistoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadingHistoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReadingProgress(updateHistoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReadingHistoryControllerApi.updateReadingProgress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReadingHistoryControllerApi - factory interface
 */
export const ReadingHistoryControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReadingHistoryControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReadingHistory(pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageReadingHistoryDto> {
            return localVarFp.getReadingHistory(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateHistoryRequest} updateHistoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReadingProgress(updateHistoryRequest: UpdateHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReadingHistoryDto> {
            return localVarFp.updateReadingProgress(updateHistoryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReadingHistoryControllerApi - object-oriented interface
 */
export class ReadingHistoryControllerApi extends BaseAPI {
    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getReadingHistory(pageable: Pageable, options?: RawAxiosRequestConfig) {
        return ReadingHistoryControllerApiFp(this.configuration).getReadingHistory(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateHistoryRequest} updateHistoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateReadingProgress(updateHistoryRequest: UpdateHistoryRequest, options?: RawAxiosRequestConfig) {
        return ReadingHistoryControllerApiFp(this.configuration).updateReadingProgress(updateHistoryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatsControllerApi - axios parameter creator
 */
export const StatsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummary: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stats/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsControllerApi - functional programming interface
 */
export const StatsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSummary(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsSummaryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSummary(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatsControllerApi.getSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatsControllerApi - factory interface
 */
export const StatsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatsControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummary(options?: RawAxiosRequestConfig): AxiosPromise<StatsSummaryDto> {
            return localVarFp.getSummary(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatsControllerApi - object-oriented interface
 */
export class StatsControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSummary(options?: RawAxiosRequestConfig) {
        return StatsControllerApiFp(this.configuration).getSummary(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StoryManagementApi - axios parameter creator
 */
export const StoryManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a single genre to an existing story without affecting other genres. Requires ADMIN or MODERATOR role.
         * @summary Add a genre to a story
         * @param {number} storyId Story ID
         * @param {number} genreId Genre ID to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGenreToStory: async (storyId: number, genreId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('addGenreToStory', 'storyId', storyId)
            // verify required parameter 'genreId' is not null or undefined
            assertParamExists('addGenreToStory', 'genreId', genreId)
            const localVarPath = `/api/stories/{storyId}/genres/{genreId}`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)))
                .replace(`{${"genreId"}}`, encodeURIComponent(String(genreId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new story with optional multiple genres. Requires ADMIN or MODERATOR role.
         * @summary Create a new story
         * @param {CreateStoryRequest} createStoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStory: async (createStoryRequest: CreateStoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createStoryRequest' is not null or undefined
            assertParamExists('createStory', 'createStoryRequest', createStoryRequest)
            const localVarPath = `/api/stories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStory: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteStory', 'id', id)
            const localVarPath = `/api/stories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturedStories: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stories/featured`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} [keyword] 
         * @param {number} [genreId] 
         * @param {string} [genre] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStories: async (pageable: Pageable, keyword?: string, genreId?: number, genre?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getStories', 'pageable', pageable)
            const localVarPath = `/api/stories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (genreId !== undefined) {
                localVarQueryParameter['genreId'] = genreId;
            }

            if (genre !== undefined) {
                localVarQueryParameter['genre'] = genre;
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} [keyword] 
         * @param {number} [genreId] 
         * @param {string} [genre] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoriesWithMetadata: async (pageable: Pageable, keyword?: string, genreId?: number, genre?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getStoriesWithMetadata', 'pageable', pageable)
            const localVarPath = `/api/stories/with-metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (genreId !== undefined) {
                localVarQueryParameter['genreId'] = genreId;
            }

            if (genre !== undefined) {
                localVarQueryParameter['genre'] = genre;
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStoryById', 'id', id)
            const localVarPath = `/api/stories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendingStories: async (limit?: number, days?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stories/trending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incrementViewCount: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('incrementViewCount', 'id', id)
            const localVarPath = `/api/stories/{id}/view`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a single genre from a story without affecting other genres. Requires ADMIN or MODERATOR role.
         * @summary Remove a genre from a story
         * @param {number} storyId Story ID
         * @param {number} genreId Genre ID to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeGenreFromStory: async (storyId: number, genreId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('removeGenreFromStory', 'storyId', storyId)
            // verify required parameter 'genreId' is not null or undefined
            assertParamExists('removeGenreFromStory', 'genreId', genreId)
            const localVarPath = `/api/stories/{storyId}/genres/{genreId}`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)))
                .replace(`{${"genreId"}}`, encodeURIComponent(String(genreId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {boolean} featured 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFeatured: async (id: number, featured: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setFeatured', 'id', id)
            // verify required parameter 'featured' is not null or undefined
            assertParamExists('setFeatured', 'featured', featured)
            const localVarPath = `/api/stories/{id}/featured`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (featured !== undefined) {
                localVarQueryParameter['featured'] = featured;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace all existing genres with a new set of genres. Send an empty array to remove all genres. Requires ADMIN or MODERATOR role.
         * @summary Set all genres for a story
         * @param {number} storyId Story ID
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGenresForStory: async (storyId: number, requestBody: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('setGenresForStory', 'storyId', storyId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('setGenresForStory', 'requestBody', requestBody)
            const localVarPath = `/api/stories/{storyId}/genres`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TranslateStoryRequest} translateStoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateStory: async (translateStoryRequest: TranslateStoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'translateStoryRequest' is not null or undefined
            assertParamExists('translateStory', 'translateStoryRequest', translateStoryRequest)
            const localVarPath = `/api/stories/translate/story`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(translateStoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateStoryById: async (storyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyId' is not null or undefined
            assertParamExists('translateStoryById', 'storyId', storyId)
            const localVarPath = `/api/stories/translate/story/{storyId}`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update story details and optionally replace all genres. Requires ADMIN or MODERATOR role.
         * @summary Update a story
         * @param {number} id Story ID
         * @param {UpdateStoryRequest} updateStoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStory: async (id: number, updateStoryRequest: UpdateStoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateStory', 'id', id)
            // verify required parameter 'updateStoryRequest' is not null or undefined
            assertParamExists('updateStory', 'updateStoryRequest', updateStoryRequest)
            const localVarPath = `/api/stories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoryManagementApi - functional programming interface
 */
export const StoryManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoryManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a single genre to an existing story without affecting other genres. Requires ADMIN or MODERATOR role.
         * @summary Add a genre to a story
         * @param {number} storyId Story ID
         * @param {number} genreId Genre ID to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addGenreToStory(storyId: number, genreId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addGenreToStory(storyId, genreId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryManagementApi.addGenreToStory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new story with optional multiple genres. Requires ADMIN or MODERATOR role.
         * @summary Create a new story
         * @param {CreateStoryRequest} createStoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStory(createStoryRequest: CreateStoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStory(createStoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryManagementApi.createStory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStory(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryManagementApi.deleteStory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeaturedStories(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StoryDetailDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeaturedStories(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryManagementApi.getFeaturedStories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} [keyword] 
         * @param {number} [genreId] 
         * @param {string} [genre] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStories(pageable: Pageable, keyword?: string, genreId?: number, genre?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageStoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStories(pageable, keyword, genreId, genre, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryManagementApi.getStories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} [keyword] 
         * @param {number} [genreId] 
         * @param {string} [genre] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStoriesWithMetadata(pageable: Pageable, keyword?: string, genreId?: number, genre?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageStoryDetailDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStoriesWithMetadata(pageable, keyword, genreId, genre, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryManagementApi.getStoriesWithMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStoryById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStoryById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryManagementApi.getStoryById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrendingStories(limit?: number, days?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StoryDetailDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrendingStories(limit, days, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryManagementApi.getTrendingStories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async incrementViewCount(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.incrementViewCount(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryManagementApi.incrementViewCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a single genre from a story without affecting other genres. Requires ADMIN or MODERATOR role.
         * @summary Remove a genre from a story
         * @param {number} storyId Story ID
         * @param {number} genreId Genre ID to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeGenreFromStory(storyId: number, genreId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeGenreFromStory(storyId, genreId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryManagementApi.removeGenreFromStory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {boolean} featured 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setFeatured(id: number, featured: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setFeatured(id, featured, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryManagementApi.setFeatured']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replace all existing genres with a new set of genres. Send an empty array to remove all genres. Requires ADMIN or MODERATOR role.
         * @summary Set all genres for a story
         * @param {number} storyId Story ID
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setGenresForStory(storyId: number, requestBody: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setGenresForStory(storyId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryManagementApi.setGenresForStory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TranslateStoryRequest} translateStoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translateStory(translateStoryRequest: TranslateStoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranslateStoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translateStory(translateStoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryManagementApi.translateStory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translateStoryById(storyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranslateStoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translateStoryById(storyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryManagementApi.translateStoryById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update story details and optionally replace all genres. Requires ADMIN or MODERATOR role.
         * @summary Update a story
         * @param {number} id Story ID
         * @param {UpdateStoryRequest} updateStoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStory(id: number, updateStoryRequest: UpdateStoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStory(id, updateStoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryManagementApi.updateStory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StoryManagementApi - factory interface
 */
export const StoryManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoryManagementApiFp(configuration)
    return {
        /**
         * Add a single genre to an existing story without affecting other genres. Requires ADMIN or MODERATOR role.
         * @summary Add a genre to a story
         * @param {number} storyId Story ID
         * @param {number} genreId Genre ID to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGenreToStory(storyId: number, genreId: number, options?: RawAxiosRequestConfig): AxiosPromise<StoryDto> {
            return localVarFp.addGenreToStory(storyId, genreId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new story with optional multiple genres. Requires ADMIN or MODERATOR role.
         * @summary Create a new story
         * @param {CreateStoryRequest} createStoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStory(createStoryRequest: CreateStoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<StoryDto> {
            return localVarFp.createStory(createStoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStory(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteStory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturedStories(limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<StoryDetailDto>> {
            return localVarFp.getFeaturedStories(limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} [keyword] 
         * @param {number} [genreId] 
         * @param {string} [genre] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStories(pageable: Pageable, keyword?: string, genreId?: number, genre?: string, options?: RawAxiosRequestConfig): AxiosPromise<PageStoryDto> {
            return localVarFp.getStories(pageable, keyword, genreId, genre, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} [keyword] 
         * @param {number} [genreId] 
         * @param {string} [genre] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoriesWithMetadata(pageable: Pageable, keyword?: string, genreId?: number, genre?: string, options?: RawAxiosRequestConfig): AxiosPromise<PageStoryDetailDto> {
            return localVarFp.getStoriesWithMetadata(pageable, keyword, genreId, genre, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<StoryDto> {
            return localVarFp.getStoryById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendingStories(limit?: number, days?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<StoryDetailDto>> {
            return localVarFp.getTrendingStories(limit, days, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incrementViewCount(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.incrementViewCount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a single genre from a story without affecting other genres. Requires ADMIN or MODERATOR role.
         * @summary Remove a genre from a story
         * @param {number} storyId Story ID
         * @param {number} genreId Genre ID to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeGenreFromStory(storyId: number, genreId: number, options?: RawAxiosRequestConfig): AxiosPromise<StoryDto> {
            return localVarFp.removeGenreFromStory(storyId, genreId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {boolean} featured 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFeatured(id: number, featured: boolean, options?: RawAxiosRequestConfig): AxiosPromise<StoryDto> {
            return localVarFp.setFeatured(id, featured, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace all existing genres with a new set of genres. Send an empty array to remove all genres. Requires ADMIN or MODERATOR role.
         * @summary Set all genres for a story
         * @param {number} storyId Story ID
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGenresForStory(storyId: number, requestBody: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<StoryDto> {
            return localVarFp.setGenresForStory(storyId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TranslateStoryRequest} translateStoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateStory(translateStoryRequest: TranslateStoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<TranslateStoryResponse> {
            return localVarFp.translateStory(translateStoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateStoryById(storyId: number, options?: RawAxiosRequestConfig): AxiosPromise<TranslateStoryResponse> {
            return localVarFp.translateStoryById(storyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update story details and optionally replace all genres. Requires ADMIN or MODERATOR role.
         * @summary Update a story
         * @param {number} id Story ID
         * @param {UpdateStoryRequest} updateStoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStory(id: number, updateStoryRequest: UpdateStoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<StoryDto> {
            return localVarFp.updateStory(id, updateStoryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StoryManagementApi - object-oriented interface
 */
export class StoryManagementApi extends BaseAPI {
    /**
     * Add a single genre to an existing story without affecting other genres. Requires ADMIN or MODERATOR role.
     * @summary Add a genre to a story
     * @param {number} storyId Story ID
     * @param {number} genreId Genre ID to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addGenreToStory(storyId: number, genreId: number, options?: RawAxiosRequestConfig) {
        return StoryManagementApiFp(this.configuration).addGenreToStory(storyId, genreId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new story with optional multiple genres. Requires ADMIN or MODERATOR role.
     * @summary Create a new story
     * @param {CreateStoryRequest} createStoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createStory(createStoryRequest: CreateStoryRequest, options?: RawAxiosRequestConfig) {
        return StoryManagementApiFp(this.configuration).createStory(createStoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteStory(id: number, options?: RawAxiosRequestConfig) {
        return StoryManagementApiFp(this.configuration).deleteStory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFeaturedStories(limit?: number, options?: RawAxiosRequestConfig) {
        return StoryManagementApiFp(this.configuration).getFeaturedStories(limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {string} [keyword] 
     * @param {number} [genreId] 
     * @param {string} [genre] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStories(pageable: Pageable, keyword?: string, genreId?: number, genre?: string, options?: RawAxiosRequestConfig) {
        return StoryManagementApiFp(this.configuration).getStories(pageable, keyword, genreId, genre, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {string} [keyword] 
     * @param {number} [genreId] 
     * @param {string} [genre] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStoriesWithMetadata(pageable: Pageable, keyword?: string, genreId?: number, genre?: string, options?: RawAxiosRequestConfig) {
        return StoryManagementApiFp(this.configuration).getStoriesWithMetadata(pageable, keyword, genreId, genre, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStoryById(id: number, options?: RawAxiosRequestConfig) {
        return StoryManagementApiFp(this.configuration).getStoryById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [days] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTrendingStories(limit?: number, days?: number, options?: RawAxiosRequestConfig) {
        return StoryManagementApiFp(this.configuration).getTrendingStories(limit, days, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public incrementViewCount(id: number, options?: RawAxiosRequestConfig) {
        return StoryManagementApiFp(this.configuration).incrementViewCount(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a single genre from a story without affecting other genres. Requires ADMIN or MODERATOR role.
     * @summary Remove a genre from a story
     * @param {number} storyId Story ID
     * @param {number} genreId Genre ID to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public removeGenreFromStory(storyId: number, genreId: number, options?: RawAxiosRequestConfig) {
        return StoryManagementApiFp(this.configuration).removeGenreFromStory(storyId, genreId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {boolean} featured 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setFeatured(id: number, featured: boolean, options?: RawAxiosRequestConfig) {
        return StoryManagementApiFp(this.configuration).setFeatured(id, featured, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace all existing genres with a new set of genres. Send an empty array to remove all genres. Requires ADMIN or MODERATOR role.
     * @summary Set all genres for a story
     * @param {number} storyId Story ID
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setGenresForStory(storyId: number, requestBody: Array<string>, options?: RawAxiosRequestConfig) {
        return StoryManagementApiFp(this.configuration).setGenresForStory(storyId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TranslateStoryRequest} translateStoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public translateStory(translateStoryRequest: TranslateStoryRequest, options?: RawAxiosRequestConfig) {
        return StoryManagementApiFp(this.configuration).translateStory(translateStoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} storyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public translateStoryById(storyId: number, options?: RawAxiosRequestConfig) {
        return StoryManagementApiFp(this.configuration).translateStoryById(storyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update story details and optionally replace all genres. Requires ADMIN or MODERATOR role.
     * @summary Update a story
     * @param {number} id Story ID
     * @param {UpdateStoryRequest} updateStoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateStory(id: number, updateStoryRequest: UpdateStoryRequest, options?: RawAxiosRequestConfig) {
        return StoryManagementApiFp(this.configuration).updateStory(id, updateStoryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



